## 가상 메모리

가상 메모리(virtual memory)는 컴퓨터 운영 체제가 물리적인 메모리(RAM)의 한계를 넘어서 프로그램에 더 많은 메모리를 사용할 수 있도록 해주는 시스템이다.
이 시스템은 디스크의 일부를 마치 실제 메모리처럼 사용하여, 프로그램이 필요로 하는 메모리 공간을 효율적으로 관리한다.
---
### 주요 기능과 역할

1. **메모리 확장** <br> 가상 메모리는 물리적인 RAM보다 큰 메모리 공간을 제공하여, 더 많은 프로그램이 동시에 실행될 수 있도록 한다. 


2. **메모리 관리** <br> 프로그램이 실제로 사용하는 부분만 물리적 메모리에 유지하고, 나머지는 디스크에 저장함으로써 메모리 사용을 최적화한다.


3. **프로세스 분리** <br> 각 프로세스는 독립적인 가상 메모리 공간을 갖게 되어, 다른 프로세스의 메모리 영역에 영향을 주지 않는다. 이는 시스템의 보안과 안정성을 향상시킨다.


4. **스왑핑** <br> 시스템은 사용되지 않는 메모리 페이지를 디스크의 스왑 공간(swap space)으로 이동시켜(RAM에서 디스크로 스왑 아웃), 필요할 때 다시 물리적 메모리로 불러온다(디스크에서 RAM으로 스왑 인).


5. **일관된 메모리 접근** <br> 프로그램은 물리적 메모리의 실제 위치에 상관없이 일관된 메모리 주소 공간을 사용한다.
---
### 장단점
1. **장점**
<br> 더 많은 메모리 공간을 제공하며, 메모리 관리를 효율적으로 할 수 있고, 여러 프로그램의 동시 실행을 가능하게 한다.


3. **단점**
<br> 가상 메모리를 사용할 때 디스크 접근이 필요하므로, RAM에 직접 접근하는 것보다 속도가 느릴 수 있다. 
<br> 따라서, 시스템이 스왑을 많이 사용하면 성능 저하가 발생할 수 있다.

---
### 페이지와 프레임

가상 메모리와 실제 메모리에서 사용되는 주요 단위는 "페이지(page)"와 "프레임(frame)"이다.

1. **가상 메모리의 단위: 페이지**
<br>가상 메모리는 "페이지"라는 단위로 구분된다.
페이지는 가상 주소 공간을 일정 크기의 블록으로 나눈 것이다.
<br>각 페이지는 가상 메모리 내에서 연속적인 주소 범위를 가지며, 일반적으로 수 KB에서 수 MB의 크기를 가진다.


2. **실제 메모리의 단위: 프레임**
<br>실제 메모리(RAM)는 "프레임"이라는 단위로 나뉜다.
프레임은 물리적 메모리를 페이지와 동일한 크기의 블록으로 나눈 것이다.


3. **페이지와 프레임의 관계**
<br> 가상 메모리 시스템에서는 가상 주소(페이지)를 물리적 주소(프레임)로 매핑하는 과정이 필요하다. 
이 매핑은 페이지 테이블을 통해 이루어지며, 프로그램이 메모리에 접근할 때 가상 주소를 물리적 주소로 변환하여 실제 메모리에 접근하게 하다.
<br> **추가적으로** 기본적인 관계 매핑은 페이지 테이블에서 이루어지지만, 현재 cpu에서 실행되는 프로세스에서 사용하는, 혹은 자주 사용되는 주소값 매핑은 TLB 라는 중간 캐시계층에 올라가 빠르게 참조될 수 있도록 한다. 
   
---
### 페이지폴트와 스레싱
페이지 폴트(page fault)와 스레싱(thrashing)은 가상 메모리 시스템에서 발생할 수 있는 두 가지 중요한 현상이다.

1. **페이지 폴트 (Page Fault)**
<br>
<br>페이지 폴트는 프로그램이 접근하려는 페이지가 물리적 메모리(RAM)에 없을 때 발생하는 현상이다. 즉, 프로그램이 요청한 데이터가 현재 메모리에 로드되어 있지 않고 디스크의 스왑 공간에 있을 때 발생한다.
<br>이러한 상황에서 운영 체제는 디스크에서 해당 페이지를 찾아 물리적 메모리로 로드하고 페이지와 프레임을 다시 매핑하는 과정을 거쳐야 한다. 이 과정에서 시스템은 잠시 멈추어야 하며, 페이지 로딩이 완료된 후 프로그램은 다시 실행을 계속한다.



2. **스레싱 (Thrashing)**
<br>
<br>스레싱은 시스템이 과도하게 많은 시간을 페이지 교체 작업에 사용하여 실제로 유용한 작업을 수행하는 시간이 매우 적어지는 현상이다.
이는 시스템에 너무 많은 프로그램이 동시에 실행되어 가용 메모리가 부족할 때 발생한다.
<br>결과적으로, 시스템은 지속적으로 페이지를 메모리와 디스크 사이에서 교체(swap)하는 데 많은 시간을 소비한다.
스레싱은 시스템의 전반적인 성능을 현저히 저하시키며, 컴퓨터가 매우 느리게 반응하는 것처럼 느껴질 수 있다.

---
### 페이지 교체 알고리즘

1. **FIFO (First-In, First-Out)**
   <br>가장 간단한 페이지 교체 알고리즘 중 하나이다.
   메모리에 가장 먼저 들어온 페이지를 가장 먼저 교체한다.
   <br>구현이 간단하지만, 오래된 페이지가 여전히 자주 사용될 수 있으므로 비효율적일 수 있다.


2. **LRU (Least Recently Used)**
   <br>각각의 페이지가 마지막으로 참조된 시간 중 가장 오래된 페이지와 교체한다.
   프로그램의 시간지역성 원리를 활용하여 효율적인 교체를 목표로 한다.
   <br>구현이 복잡하고, 페이지의 사용 기록을 관리해야 하는 비용이 발생한다.


3. **LFU (Least Frequently Used)**
   <br>가장 적게 사용된 페이지를 교체한다.
   <br>사용 빈도를 기반으로 하기 때문에, 오래되었지만 자주 사용되는 페이지는 메모리에 남게 된다.
   LFU 역시 구현 복잡성과 관리 비용이 발생한다.


4. **OPT (Optimal Page Replacement)**
   <br>미래에 가장 오랫동안 사용되지 않을 페이지를 교체한다.
   이상적이지만 실제 시스템에서는 구현이 불가능한 알고리즘이다. 주로 이론적인 비교 분석에 사용된다.


5. **Clock (또는 Second Chance Algorithm)**
   <br> FIFO와 유사하지만, 각 페이지에 '사용됨' 플래그를 추가하여 두 번째 기회를 제공한다.
   페이지가 선택될 때 '사용됨' 플래그가 설정되어 있다면, 플래그를 초기화하고 다음 페이지로 이동한다.
   FIFO보다 효율적이면서 구현이 상대적으로 간단한다.